[TOC]

# 分布式锁

## NPC 问题

分布式系统有几个无法回避的问题，我把它们称为 NPC 问题：

- N 指 Network delay 网络延迟

- P 是指 Process pause 进程暂停

- C 指代 Clock drift 时钟漂移

以进程暂停为例，进程 A 刚刚拿到分布式锁，然后因为 GC 等原因进程被冻结暂停，过去 1 分钟之后，分布式锁超时了，进程 B 顺利抢到同一把锁，接下来进程 A 的 GC 结束了。好了，现在俩进程都觉得自己是锁的唯一持有人。

## Redis 分布式锁

redis 分布式锁可能遇到的问题及解决方法：

- **死锁**：设置过期时间
- **过期时间评估不好，锁提前过期**：守护线程，自动续期
- **锁被别人释放**：锁写入唯一标识，释放锁先检查标识，再释放

### Redis 安全性思考

#### 锁在「单个」Redis 实例中可能产生的问题

如果我们不采用「守护线程，自动续期这」种方案。Redis 会产生我们前面 NPC 问题所举的例子。

如果我们自动续期锁，那么又会出现另一个问题

- redis 分布式锁过期了，守护线程，自动续期。如果业务代码出现 bug 一直死循环无法结束，会存在一直续费，这会导致死锁。

这种问题也是 redis 分布式锁无法避免的 **NPC 问题**，这个时候我们只能通过监控或日志去发现异常，手动解决出现的 bug。

#### 主从集群 + 哨兵的模式部署 Redis

而我们在使用 Redis 时，一般会采用**主从集群 + 哨兵**的模式部署，这样做的好处在于，当主库异常宕机时，哨兵可以实现「故障自动切换」，把从库提升为主库，继续提供服务，以此保证可用性。

**那当「主从发生切换」时，这个分布锁会依旧安全吗？**

试想这样的场景：

1. 客户端 1 在主库上执行 SET 命令，加锁成功
2. 此时，主库异常宕机，SET 命令还未同步到从库上（主从复制是异步的）
3. 从库被哨兵提升为新主库，这个锁在新的主库上，丢失了

可见，当引入 Redis 副本后，分布锁还是可能会受到影响。

## Zookeeper 分布式锁

Zookeeper 实现的分布式锁：

1. 客户端 1 和 2 都尝试创建「临时节点」，例如 /lock
2. 假设客户端 1 先到达，则加锁成功，客户端 2 加锁失败
3. 客户端 1 操作共享资源
4. 客户端 1 删除 /lock 节点，释放锁

Zookeeper 不像 Redis 那样，需要考虑锁的过期时间问题，它是采用了「临时节点」，保证客户端 1 拿到锁后，只要连接不断，就可以一直持有锁。

而且，如果客户端 1 异常崩溃了，那么这个临时节点会自动删除，保证了锁一定会被释放。

客户端 1 创建临时节点后，Zookeeper 是如何保证让这个客户端一直持有锁呢？

原因就在于，**客户端 1 此时会与 Zookeeper 服务器维护一个 Session，这个 Session 会依赖客户端「定时心跳」来维持连接。**

如果 Zookeeper 长时间收不到客户端的心跳，就认为这个 Session 过期了，也会把这个临时节点删除。

### Zookeeper 锁一定安全吗？

同样地，基于此问题，我们也讨论一下 **NPC 问题**对 Zookeeper 的锁有何影响（以进程暂停为例）：

1. 客户端 1 创建临时节点 /lock 成功，拿到了锁
2. 客户端 1 发生长时间 GC
3. 客户端 1 无法给 Zookeeper 发送心跳，Zookeeper 把临时节点「删除」
4. 客户端 2 创建临时节点 /lock 成功，拿到了锁
5. 客户端 1 GC 结束，它仍然认为自己持有锁（冲突）

所以，这里我们就能得出结论了：**一个分布式锁，在极端情况下，不一定是安全的。**

### Zookeeper 的优点

1. 不需要考虑锁的过期时间
2. watch 机制，加锁失败，可以 watch 等待锁释放，实现乐观锁

但它的劣势是：

1. 性能不如 Redis
2. 部署和运维成本高
3. 客户端与 Zookeeper 的长时间失联，锁被释放问题

## 参考文章

- 使用Redis实现分布式锁和ZK实现分布式锁有什么区别，分别有哪些场景? - Kaito的回答 - 知乎 https://www.zhihu.com/question/452803310/answer/1931377239

- 怎样实现redis分布式锁？ - 阿里开发者的回答 - 知乎 https://www.zhihu.com/question/300767410/answer/1749442787