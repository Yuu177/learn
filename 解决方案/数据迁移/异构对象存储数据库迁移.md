[TOC]

# 异构对象存储数据库迁移

方案：在业务层上增加多一层硬编码。

```go
func DoHandle(key string) {
	oldDB.DoHandle(key)
	newDB.DoHandle(key)
}
```

## 灰度

使用新数据库返回值。

我们双写双读都是以旧的数据库的返回值为准。我们可以通过灰度来慢慢切换到读写返回值都是使用新的数据库返回。

- 按照业务维度去灰度

- 按照用户百分比去灰度

- 按照白名单去灰度

> 准确来说这里需要有两个灰度需要执行：1、读写灰度。一开始我们不可能全部放开新数据库的读写，所以我们这里是通过业务的维度去逐步放开。2、使用新数据库读写放回值灰度：最终结果是我们需要用户全部使用新的数据库。这个过程需要慢慢切换。下面我们说的灰度是指第二个——使用新数据库读写放回值。

## 双写

迁移开始需要先双写。我们需要把新增的数据写入新旧数据库。之后再把旧的数据库的旧数据同步到新数据库。这里我们采用 go 协程来分别异步写新旧数据库。

- 直接一开始上来就双写吗？

当然不是。默认写旧的数据库。新的数据我们也根据业务维度来慢慢放开双写，减少万一出问题对线上的影响。

- 双写的返回值以哪个数据库为准？

开启双写后我们还是需要默认返回旧数据库写返回。新的数据库写返回等到用户灰度的时候再使用。

- 双写失败应该怎么操作？

因为我们开始返回的都是旧数据库的写返回。所以在灰度切换前以写旧的返回值为主。这部分添加写旧/新数据成功和失败的日志和监控记录即可。

> 这里没有所谓的事务回滚，写入了就是写入了，不可能说把新旧数据库看做为一个事务进行操作。对象存储没有事务这个说法（好像）

因为我们写入的数据最终要读取出来，所以我们把重点关注在读新老数据库的结果。

## 双读

- 什么时候双读

我们开启双写的时候就同时进行双读了（根据业务维度）。

- 双读失败要怎么处理

我们双读的时候有个比较的 func。如果有一个数据读取失败，那么我们就上报监控和日志结果为 diff。如果新旧数据库都读取成功，那么我们把读取到的内容再进行 MD5 比较。如果 MD5 相同，我们上报 same（说明新旧数据库读取到的内容一样），否则上报 MD5-no-same。记录日志等待后续决定是否手动进行补偿。

- 什么时候切读（灰度使用新的读返回）

一开始我们以旧数据库的读返回为准，切读就是使用后新的数据库读返回。

如果监控观察到新旧数据库的数据读取结果对比基本没有差异就可以切读了。

根据监控上我们当观察到监控都是上报 same 的时候，就说明新老数据库的数据基本趋于一致了，这个时候我们就可以灰度了。

如果发现监控一直有 diff 或者 MD5-no-same，就需要查看日志是哪个文件有问题，是否需要手动做补偿。

- 使用老的还是新的数据库返回值

灰度前用旧，灰度后用新。

## 停读

待所有的用户双读并且都使用了新的数据库返回一段时间确认没有问题后，停止老的数据库读。

## 停写

待停读一段时间系统运行稳定后，停止老数据库写。

## 其他补充

### MD5

MD5 信息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个 128位（16字节）的散列值（hash value），用于确保信息传输完整一致。

每个文件对应的 md5 值是固定的，文件内容发生变化时，md5 值也会发生变化。文件内容相同时，md5 值相同。所以，md5 值可以作为文件的唯一标识符。

如果想知道下载的文件和原文件是否一模一样，就可以查看文件的 md5 值。

