[TOC]

# 克鲁斯卡尔

```cpp
#include <algorithm>
#include <vector>

using namespace std;

// 定义边
struct Edge {
  int u, v, w;
  bool operator<(const Edge& other) const { return w < other.w; }
};

// 定义并查集节点
struct Node {
  int parent, rank;
};

// 并查集操作：查找根节点
int find(vector<Node>& nodes, int x) {
  if (nodes[x].parent != x) {
    nodes[x].parent = find(nodes, nodes[x].parent);
  }
  return nodes[x].parent;
}

// 并查集操作：合并两棵树
void merge(vector<Node>& nodes, int x, int y) {
  int xRoot = find(nodes, x);
  int yRoot = find(nodes, y);
  if (xRoot == yRoot) {
    return;
  }
  if (nodes[xRoot].rank < nodes[yRoot].rank) {
    nodes[xRoot].parent = yRoot;
  } else if (nodes[xRoot].rank > nodes[yRoot].rank) {
    nodes[yRoot].parent = xRoot;
  } else {
    nodes[yRoot].parent = xRoot;
    nodes[xRoot].rank++;
  }
}

// 克鲁斯卡尔算法
int kruskal(int n, vector<Edge>& edges) {
  // 初始化并查集
  vector<Node> nodes(n);
  for (int i = 0; i < n; i++) {
    nodes[i] = {i, 0};
  }

  // 按边权排序
  sort(edges.begin(), edges.end());

  int cost = 0;
  for (const Edge& e : edges) {
    int u = e.u, v = e.v, w = e.w;
    // 如果 u 和 v 不在同一个连通块中，则将它们合并
    if (find(nodes, u) != find(nodes, v)) {
      cost += w;
      merge(nodes, u, v);
    }
  }

  return cost;
}

int main() {
  // 示例使用的边和边权
  vector<Edge> edges = {{0,0,0}};
}
```

