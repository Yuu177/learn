[TOC]

# 最短路径

处理最短路径问题有以下三大算法：

1. Dijkstra 算法：这是一种贪心算法，用于计算单源最短路径。它需要边权为非负值。
2. Bellman-Ford 算法：这是一种动态规划算法，用于计算单源最短路径。它能够处理负权边，但是比 Dijkstra 算法慢。
3. Floyd-Warshall 算法：这是一种矩阵乘法算法，用于计算任意两点之间的最短路径。它能够处理负权边，但是时间复杂度较高。

## 最短路径和最小生成树的区别

最小生成树能够保证整个拓扑图的所有路径之和最小，但不能保证任意两点之间是最短路径。

最短路径是从一点出发，到达目的地的路径最小。

最小生成树所有点被连通  。把连通的图的所有顶点连起来路径之和最小的问题，即生成树总权值之和最小。是整体来分析。

最短路径不一定所有点。只着眼于点与点之间的路径问题，并不关注整个图，也就意味着对一个节点运行算法的结果与另一个节点的结果之间没有多少关系。是单条路径来分析。

## Dijkstra 算法

Dijkstra 算法是一种贪心算法，它的基本思想是在一张有向图中求单源最短路径。

在 Dijkstra 算法中，我们从源点开始，每次找到距离源点最近的点，然后从该点出发更新它的邻居的距离，最终得到从源点到所有点的最短路径。

具体来说，Dijkstra 算法的基本步骤如下：

1. 初始化源点到其他点的距离为正无穷（源节点自己和自己的距离为 0）。
2. 每次从未标记的节点（未加入最短路径的点集合）中选择距离出发点（源点）最近的节点 u 进行标记，加入到最短路径集合中。
3. 从 u 出发更新其他点的距离，对于每一个邻接点 v，计算经过 u 点到 v 的距离（u 当前距离源点的长度 + u 到 v 的长度），如果这个距离比 v 点当前的距离源点更短，就更新 v 点的距离。并且记录 v 的前节点 u。
4. 重复步骤 2 和步骤 3，直到所有的点都被加入已经找到的最短路径的点集合中。

需要注意的是，Dijkstra 算法只能用于解决有向图中的单源最短路径问题，并且它只能处理权值为非负数的图。如果图中存在负权边，则 Dijkstra 算法不适用。

此外，Dijkstra 算法也可以用于解决最短路径树问题，即求出从源点到所有点的最短路径构成的树。在这种情况下，我们只需要在每次更新点 u 的邻接点 v 的距离时，将 u 和 v 之间的边加入最短路径树中即可。

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

// 定义常量 N 和 M，表示图中点的个数和边的个数
const int N = 510, M = 10010, INF = 0x3f3f3f3f;

// 定义全局变量：点的个数 n，边的个数 m，起点 st，终点 ed
// 邻接矩阵数组 h，边的数组 e 和 w，以及边的 next 指针数组 ne
// 距离数组 dis，以及已经找到最短路径的点的标记数组 vis
int n, m, st, ed;
int h[N], e[M], ne[M], w[M], dis[N];
bool vis[N];

// 定义邻接矩阵存储图的 add 函数
void add(int a, int b, int c)
{
    // 将边存储到边数组 e 中，边权存储到边权数组 w 中
    e[m] = b, w[m] = c;
    // 将当前边的 next 指针指向点 a 在邻接矩阵中的第一条边
    ne[m] = h[a];
    // 将点 a 在邻接矩阵中的第一条边更新为当前边
    h[a] = m ++ ;
}

// 定义 Dijkstra 算法函数
void dijkstra(int s)
{
    // 将 dis 数组初始化为正无穷
    fill(dis, dis + N, INF);
    // 将 vis 数组初始化为 false
    fill(vis, vis + N, false);
    // 将起点的距离设置为 0
    dis[s] = 0;
    // 外层循环，循环 n 次
    for (int i = 0; i < n; i ++ )
    {
        // 定义当前最小距离的点 t 为 -1
        int t = -1;
        // 内层循环，遍历每一个点
        for (int j = 0; j < n; j ++ )
        {
            // 如果当前点没有被访问过，并且当前点的距离比 t 点的距离还小
            if (!vis[j] && (t == -1 || dis[j] < dis[t]))
                // 将当前点设置为 t 点
                t = j;
        }
        // 将 t 点标记为已经访问过
        vis[t] = true;

        // 遍历 t 点的邻居
        for (int j = h[t]; j != -1; j = ne[j])
        {
            // 取出 t 点的邻居 v
            int v = e[j];
            // 如果从 t 点出发到 v 点的距离比 v 点当前的距离要小
            if (dis[v] > dis[t] + w[j])
            {
                // 更新 v 点的距离
                dis[v] = dis[t] + w[j];
            }
        }
    }
}

int main()
{
    // 读入点的个数 n，边的个数 m，起点 st，终点 ed
    cin >> n >> m >> st >> ed;
    // 初始化邻接矩阵，将所有点的第一条边设置为 -1
    memset(h, -1, sizeof h);

    // 读入边的信息并加入图中
    while (m -- )
    {
        int a, b, c;
        cin >> a >> b >> c;
        add(a, b, c);
    }

    // 调用 Dijkstra 算法求最短路径
    dijkstra(st);

    // 输出终点的最短路径
    cout << dis[ed] << endl;

    return 0;
}

```

- 时间复杂度

上面的代码时间复杂度为 `O(N^2)`，我们可以通过最小堆来优化查询为标记且到源点最近距离的点，优化后时间复杂度为 `O(NlogN)`。

## 参考文章

- [【算法】最短路径查找—Dijkstra 算法 - B 站](https://www.bilibili.com/video/BV1zz4y1m7Nq/?spm_id_from=333.1007.top_right_bar_window_history.content.click&vd_source=51260d25382c5147c8b23cc6581c2b75)