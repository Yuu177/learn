[TOC]

# 最小生成树

最小生成树问题是指，给定一个带权的无向连通图，要找出一棵生成树，使得这棵生成树的边权之和最小。

换句话说，一个有 N 个点的图，边一定是大于等于 N-1 条的。图的最小生成树，就是在这些边中选择 N-1 条出来，**连接所有的 N 个点**。这 N-1 条边的边权之和是所有方案中最小的。

最小生成树算法的常见实现方式有两种：克鲁斯卡尔算法（Kruskal's algorithm）和最小生成树算法（Prim's algorithm）。

- 克鲁斯卡尔算法是一种基于排序的贪心算法，它将图中的所有边按照权值从小到大排序，然后依次将每条边加入生成树中，如果加入后不会形成环，则保留这条边，否则舍弃。这样，就可以得到一棵最小生成树。

- 最小生成树算法是一种基于贪心的算法，它每次选择与当前生成树相连的最短边，并将这条边加入生成树中。这样，就可以得到一棵最小生成树。

## 克鲁斯卡尔算法

首先将边按照权值从小到大排序，然后依次加入边，并判断加入该边是否会形成环，如果会形成环（边的两点是否连通）就舍弃该边，否则就加入该边。这样，在所有边都被加入之后，就可以得到最小生成树。

![Kruskal](.最小生成树.assets/Kruskal.webp)

**代码待修改完善...**

```cpp
#include <algorithm>
#include <vector>

using namespace std;

// 定义边结构体，包含边的起点 u、终点 v 和边权 w
struct Edge {
    int u, v, w;
    bool operator<(const Edge& other) const { return w < other.w; }
};

// 定义并查集节点
struct Node {
    int parent, rank;
};

// 并查集操作：查找根节点
int find(vector<Node>& nodes, int x) {
    if (nodes[x].parent != x) {
        nodes[x].parent = find(nodes, nodes[x].parent);
    }
    return nodes[x].parent;
}

// 并查集操作：合并两棵树
void merge(vector<Node>& nodes, int x, int y) {
    int xRoot = find(nodes, x);
    int yRoot = find(nodes, y);
    if (xRoot == yRoot) {
        return;
    }
    if (nodes[xRoot].rank < nodes[yRoot].rank) {
        nodes[xRoot].parent = yRoot;
    } else if (nodes[xRoot].rank > nodes[yRoot].rank) {
        nodes[yRoot].parent = xRoot;
    } else {
        nodes[yRoot].parent = xRoot;
        nodes[xRoot].rank++;
    }
}

// 克鲁斯卡尔算法
int kruskal(int n, vector<Edge>& edges) {
    // 初始化并查集
    vector<Node> nodes(n);
    for (int i = 0; i < n; i++) {
        nodes[i] = {i, 0};
    }

    // 按边权排序
    sort(edges.begin(), edges.end());

    int cost = 0;
    for (const Edge& e : edges) {
        int u = e.u, v = e.v, w = e.w;
        // 如果 u 和 v 不在同一个连通块中，则将它们合并
        if (find(nodes, u) != find(nodes, v)) {
        cost += w;
        merge(nodes, u, v);
        }
    }

    return cost;
}

int main() {
    // 示例使用的边和边权
    vector<Edge> edges = {{0,0,0}};
}
```

- 时间复杂度

对 e 条边各扫描一次，每次选择最小代价的边仅需要 `O(loge)` 的时间（并查集 `find` 函数递归）。因此，克鲁斯卡尔算法的时间复杂度为 `O(eloge)`。

**待补充...**

## 最小生成树算法（普里姆算法）

- 时间复杂度

最小生成树算法的时间复杂度通常为 O(n^2)

## 两大算法区别

Prim 算法注重于点，Kruskal 算法注重边。

Prim 算法适用于点少边多（稠密）的情况。

Kruskal 算法适用于点多边少（稀疏）的情况。



## 参考文章

